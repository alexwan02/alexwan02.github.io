<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Android：DataBinding Guide - Alex Studio
        
    </title>

    <link rel="canonical" href="http://blog.alexwan.cn/2016/07/17/Android：DataBinding-Guide/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Alex Studio</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://blog.alexwan.cn/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#android-mvvm" title="android-mvvm">android-mvvm</a>
                        
                    </div>
                    <h1>Android：DataBinding Guide</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by AlexWan on
                        2016-07-17
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="一、编译环境配置"><a href="#一、编译环境配置" class="headerlink" title="一、编译环境配置"></a>一、编译环境配置</h2><h3 id="1-build-gradle"><a href="#1-build-gradle" class="headerlink" title="1. build.gradle"></a>1. build.gradle</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">android&#123;</div><div class="line">    ...</div><div class="line">    dataBinding&#123;</div><div class="line">        enabled <span class="keyword">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在依赖module中需要支持databinding库，则在对应的依赖module的build.gradle配置文件添加dataBinding。</p>
<h3 id="2-DataBinding-布局文件"><a href="#2-DataBinding-布局文件" class="headerlink" title="2. DataBinding 布局文件"></a>2. DataBinding 布局文件</h3><p>使用DataBinding库的布局文件与普通布局文件不同的是：跟标签使用<code>&lt;layout/&gt;</code>：包含<code>&lt;data&gt;&lt;/data&gt;</code>标签和普通的视图布局。<br><figure class="highlight xml"><figcaption><span>activity_main.xml</span></figcaption><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>示例中的<data>中的user变量用<variable>标签来引用：用<code>@{}</code>语法表示绑定的参数<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">...</div><div class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</div></pre></td></tr></table></figure></variable></data></p>
<p><code>@{user.firstName}</code>意味：User中的firstName对应的具体<br>Java POJO 类有两种方式</p>
<ol>
<li><p>老式；一旦数据初始化后，值无法再次修改</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String firstName;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String lastName;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String firstName , String lastName)</span></span>&#123;</div><div class="line">	    <span class="keyword">this</span>.firstName = firstName;</div><div class="line">	    <span class="keyword">this</span>.lastName = lastName;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>或使用私有private的java POJO类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.firstName = firstName;</div><div class="line">       <span class="keyword">this</span>.lastName = lastName;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>从DataBinding角度来看，两个Java POJO类的效果相同。使用第一种Java类，TextView的android:text中表达式<code>@{user.firstName}</code>直接访问User的firstName字段。如果使用第二种类型Java类，则通过调用<code>getFirstName()</code>来访问User的firstName字段。</p>
<blockquote>
<p>注：如果User类中存在firstName()方法，则首先调用firstName()方法。</p>
</blockquote>
<h3 id="3-绑定数据"><a href="#3-绑定数据" class="headerlink" title="3. 绑定数据"></a>3. 绑定数据</h3><p>默认情况下，会根据布局文件的名称，在编译时自动生成首字母大写、驼峰式命名方式并以<code>Binding</code>结尾的Binding类。比如有名称为<code>main_activity.xml</code>的布局文件，则在编译时生成<code>MainActivityBinding.java</code>类。类中有布局绑定的data信息（如main_activity.xml中的user）并生成data的setter方法。最简单地创建binding方式就是在inflate布局时。</p>
<figure class="highlight java"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="code"><pre><div class="line">...</div><div class="line"><span class="meta">@override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">	MainActivityBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span> , R.layout.main_activity);</div><div class="line">	User user = <span class="keyword">new</span> User(<span class="string">"Test"</span> , <span class="string">"User"</span>);</div><div class="line">	binding.setUser(user);</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>或通过编译生成的MainActivityBinding类创建Binding</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater);</div></pre></td></tr></table></figure>
<p>如果绑定的是ListView或RecyclerView对应的Adapter，对应的binding类为ListItemBinding</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ListItemBinding binding = ListItemBinding.inflater(layoutInflater , viewGroup , <span class="keyword">false</span>);</div><div class="line"><span class="comment">// or</span></div><div class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<h2 id="二、事件处理"><a href="#二、事件处理" class="headerlink" title="二、事件处理"></a>二、事件处理</h2><p>DataBinding可以使用表达式来处理View的事件分发操作（如：onClick）。事件属性名由监听方法统一管理。如<a href="https://developer.android.com/reference/android/view/View.OnLongClickListener.html" target="_blank" rel="external">View.onLongClickListener</a>的方法<a href="https://developer.android.com/reference/android/view/View.OnLongClickListener.html#onLongClick(android.view.View" target="_blank" rel="external">onLongClick()</a>)，则对应属性名为<code>android:onLongClick</code>。处理View事件分发有两种方式</p>
<ol>
<li>方法关联（<a href="https://developer.android.com/topic/libraries/data-binding/index.html#method_references" target="_blank" rel="external">Method References</a>）方式：在表达式中应用符合签名的监听方法。如果表达式签名与对应的方法引用一致，DataBinding将包裹引用的方法和对象到绑定的方法中。如果表达式为null，则不会创建监听。</li>
<li>监听绑定（<a href="https://developer.android.com/topic/libraries/data-binding/index.html#listener_bindings" target="_blank" rel="external">Listener Bindings</a>）方式：在触发监听事件时，则调用绑定的lambda表达式。使用这个方式，DataBinding总是会创建View的监听事件。触发View事件时，调用lambda表达式绑定的方法。</li>
</ol>
<h3 id="1-方法关联"><a href="#1-方法关联" class="headerlink" title="1. 方法关联"></a>1. 方法关联</h3><p>直接将View对应的事件绑定到对应的方法。类似<code>android:onClick</code>关联Activity中的同名方法。比View#onClick属性相比，最大的好处就是这种方式只在编译时生成。所以在方法不存在或签名不正确时，则在编译阶段直接出错。<br>方法关联与监听绑定最大的不同就是：实际的Listener是在数据绑定时而不是在事件出发创建。如果希望只在View事件触发时执行表达式，则应该使用<a href="https://developer.android.com/topic/libraries/data-binding/index.html#listener_bindings" target="_blank" rel="external">监听绑定</a>的方式。<br>使用与处理方法名相同的表达式来关联监听事件，假设定义了如下的事件处理的类和方法<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlers</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickFriend</span><span class="params">(View view)</span></span>&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>则要在布局文件中通过<variable> 来声明事件处理类</variable></p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="urf-8"?&gt;</div><div class="line">&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt;</div><div class="line">   &lt;data&gt;</div><div class="line">       &lt;!-- 声明View的事件处理类 --&gt;</div><div class="line">       &lt;variable name="handlers" type="com.example.Handlers"/&gt;</div><div class="line">       &lt;variable name="user" type="com.example.User"/&gt;</div><div class="line">   &lt;/data&gt;</div><div class="line">   &lt;LinearLayout</div><div class="line">       android:orientation="vertical"</div><div class="line">       android:layout_width="match_parent"</div><div class="line">       android:layout_height="match_parent"&gt;</div><div class="line">       &lt;TextView android:layout_width="wrap_content"</div><div class="line">           android:layout_height="wrap_content"</div><div class="line">           android:text="@&#123;user.firstName&#125;"</div><div class="line">           &lt;!-- 绑定声明的事件处理类的对应监听方；保证方法存在且命名相同 --&gt;</div><div class="line">           android:onClick="@&#123;handlers::onClickFriend&#125;"/&gt;</div><div class="line">   &lt;/LinearLayout&gt;</div><div class="line">&lt;/layout&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：要保证表达式中的方法名签名与事件处理类一致：方法存在且名称一致。</p>
</blockquote>
<h3 id="2-监听绑定"><a href="#2-监听绑定" class="headerlink" title="2. 监听绑定"></a>2. 监听绑定</h3><p>与方法关联类似，但只在触发View响应事件时绑定表达式。表达式中允许存在多个参数（需要Gradle插件版本2.0以上）。<br>在方法关联中，方法参数必须符合事件监听的参数。在监听绑定中，只要求返回值符合监听表达式返回的值（除非返回void）。通过触发View事件调用绑定事件处理类中的方法。使用方法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveClick</span><span class="params">(Task task)</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>绑定点击事件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"task"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Task"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"presenter"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Presenter"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Button</span> </span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span> </div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:onClick</span>=<span class="string">"@&#123;() -&gt; presenter.onSaveClick(task)&#125;"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用lambda表达式的Listener只允许作为表达式的根元素。当表达式调用事件的回调方法时，DataBinding自动创建和注册必要的监听事件。当View分发事件时，DataBinding则通过事件分发调用绑定的表达式事件。在常规绑定的表达式中，可以得到值为null且线程安全的DataBinding，在执行View事件分发操作时。<br>在上面的例子中，我们并没有定义<a href="https://developer.android.com/reference/android/view/View.OnClickListener.html#onClick(android.view.View" target="_blank" rel="external">onClick(android.view.View)</a>)方法中用到的view参数。在监听绑定的方式中，为Listener的参数提供了两种方式。</p>
<ol>
<li><p>）忽略监听中所有的方法或名称</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">android:onClick=<span class="string">"@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;"</span></div></pre></td></tr></table></figure>
</li>
<li><p>）在自定义的方法中命名要使用的参数</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveClick</span><span class="params">(View view , Task task)</span></span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line">   <span class="comment">// Layout </span></div><div class="line">...</div><div class="line">android:onClick=<span class="string">"@&#123;(theView) -&gt; presenter.onSaveClick(theView ,task)&#125;"</span></div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以使用有多个参数的lambda表达式<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletedChanged</span><span class="params">(Task task, <span class="keyword">boolean</span> completed)</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Layout</span></div><div class="line"></div><div class="line">&lt;CheckBox android:layout_width=<span class="string">"wrap_content"</span> </div><div class="line">    android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">    android:onCheckedChanged=<span class="string">"@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>如果监听的事件返回值不是<code>void</code>类型，则自定义的表达式也必须要返回相同类型的值。如监听<code>onLongClick</code>时，则自定义的表达式必须要返回boolean类型。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View view, Task task)</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Layout</span></div><div class="line">android:onLongClick=<span class="string">"@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;"</span></div></pre></td></tr></table></figure></p>
<p>如果因为null对象无法执行表达式，则Data Binding 会返回默认同种类型的Java 值。如引用类型为null，int为0，boolean默认值false 等。<br>如果使用断言类型的表达式（如：三目运算），则可以使用<code>void</code>作为标识符<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:onClick="@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;"</div></pre></td></tr></table></figure></p>
<h3 id="3-避免使用复杂监听"><a href="#3-避免使用复杂监听" class="headerlink" title="3. 避免使用复杂监听"></a>3. 避免使用复杂监听</h3><p>监听表达式可以让代码易读性更好。但是含有复杂表达式的监听只会让你的布局易读性变差，更难维护。这些表达式<br>应该尽量简单，在回调方法中来实现业务逻辑。如果有特殊点击事件，需要指定除”android:onClick”之外的属性，<br>来避免冲突。下面的属性用来避免重复</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developer.android.com/reference/android/widget/SearchView.html" target="_blank" rel="external">SearchView</a></td>
<td>setOnSearchClickListener(View.OnClickListener)</td>
<td>android:onSearchClick</td>
</tr>
<tr>
<td><a href="https://developer.android.com/reference/android/widget/ZoomControls.html" target="_blank" rel="external">ZoomControls</a></td>
<td>setOnZoomInClickListener(View.OnClickListener)</td>
<td>android:onZoomIn</td>
</tr>
<tr>
<td><a href="https://developer.android.com/reference/android/widget/ZoomControls.html" target="_blank" rel="external">ZoomControls</a></td>
<td>setOnZoomOutClickListener(View.OnClickListener)</td>
<td>android:onZoomOut</td>
</tr>
</tbody>
</table>
<h2 id="三、布局详解"><a href="#三、布局详解" class="headerlink" title="三、布局详解"></a>三、布局详解</h2><h3 id="1-Imports"><a href="#1-Imports" class="headerlink" title="1. Imports"></a>1. Imports</h3><p>在data中不用或引入多个import元素。类似Java的import<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;data&gt;</div><div class="line">    &lt;import type="android.view.View"/&gt;</div><div class="line">&lt;/data&gt;</div></pre></td></tr></table></figure></p>
<p>现在可以在表达式中使用View了<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:visibility</span>=<span class="string">"@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>导入的类名冲突时，可以使用别名来避免<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.real.estate.View"</span></span></div><div class="line">        <span class="attr">alias</span>=<span class="string">"Vista"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>导入类型可以用来作为变量和表达式的类型引用<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.List"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"User"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"userList"</span> <span class="attr">type</span>=<span class="string">"List&lt;User&gt;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：Android Studio尚未支持import的处理，所以IDE可能无法处理导入的变量。但是应用仍可以正常运行。<br>可以在变量中使用完全限定名解决IDE的问题</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">"@&#123;((User)(user.connection)).lastName&#125;"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure>
<p>表达式可以使用导入类型的静态字段和静态方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.MyStringUtils"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">"@&#123;MyStringUtils.capitalize(user.lastName)&#125;"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure>
<h3 id="2-Variables-变量"><a href="#2-Variables-变量" class="headerlink" title="2. Variables 变量"></a>2. Variables 变量</h3><p>data中可以使用任意数量的variable元素<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;data&gt;</div><div class="line">    &lt;import type="android.graphics.drawable.Drawable"/&gt;</div><div class="line">    &lt;variable name="user"  type="com.example.User"/&gt;</div><div class="line">    &lt;variable name="image" type="Drawable"/&gt;</div><div class="line">    &lt;variable name="note"  type="String"/&gt;</div><div class="line">&lt;/data&gt;</div></pre></td></tr></table></figure></p>
<p>变量的类型检查均在编译时完成，所以如果是实现 <a href="https://developer.android.com/reference/android/databinding/Observable.html" target="_blank" rel="external">Observable</a>或 <a href="https://developer.android.com/topic/libraries/data-binding/index.html#observable_collections" target="_blank" rel="external">Observable Collections</a>类型的变量则对应声明时的类型。如果变量或基类没有实现Observable*系列接口，则无法被观察，即无法实现动态绑定。<br>当有不同配置的布局文件（如水平、垂直），变量则会被组合到一起，可能会出现命名冲突，所以这些布局的文件中不允许出现重复定义。<br>生成的绑定类会为每个变量生成getter和setter方法，在调用setter方法之前，变量为java默认值。在必要情况下，DataBinding会生成名为context的特殊变量，context的值为root view的<a href="https://developer.android.com/reference/android/view/View.html#getContext(" target="_blank" rel="external">getContext</a>)返回值。如果在布局中显示指定具有相同的名称的context, 默认值则被覆盖。</p>
<h2 id="四、自定义生成Binding的类名"><a href="#四、自定义生成Binding的类名" class="headerlink" title="四、自定义生成Binding的类名"></a>四、自定义生成Binding的类名</h2><p>默认情况，Binding类根据布局文件名，以驼峰形式，以”Binding”为后缀的来命名，位于module中的databinding包下。如”contact_item.xml”会生成ContactItemBinding的Binding类。如果module包名为<code>com.example.my.app</code> ,则生成的Binding 类位于com.example.my.app.databinding包下。<br>Binding 类可以在data元素中用class 来重命名<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">class</span>=<span class="string">"ContactItem"</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>则生成ContactItem，位于module的databinding包中。<br>如果类需要生成在module的根目录，则添加添加前缀”.”<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">class</span>=<span class="string">".ContactItem"</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>或者指定包中<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">class</span>=<span class="string">"com.example.ContactItem"</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="3-Includes布局"><a href="#3-Includes布局" class="headerlink" title="3. Includes布局"></a>3. Includes布局</h3><p>如果使用include方式添加布局文件时，可以用命名空间(namespace)和变量名传递<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">        <span class="attr">xmlns:bind</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</div><div class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/name"</span></span></div><div class="line">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/contact"</span></span></div><div class="line">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：name.xml 和 contact中必须也有user变量<br>对应的include的布局<data>的变量名必须要与引用它的布局属性名一致</data></p>
</blockquote>
<p>Data Binding不支持使用<merge>作为直接子元素的布局，例如不支持类似以下的使用方式<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">        <span class="attr">xmlns:bind</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</div><div class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">merge</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/name"</span></span></div><div class="line">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/contact"</span></span></div><div class="line">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">merge</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></merge></p>
<h3 id="4-支持的表达式运算符"><a href="#4-支持的表达式运算符" class="headerlink" title="4. 支持的表达式运算符"></a>4. 支持的表达式运算符</h3><p>1）常用特性<br>与Java表达式类似</p>
<ul>
<li>四则运算      + - / * %</li>
<li>字符串连接   +</li>
<li>逻辑运算符   &amp;&amp; ||</li>
<li>二元运算符   &amp; | ^</li>
<li>一元运算符   + - ! ~</li>
<li>移位运算符   &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>
<li>比较             == &gt; &lt; &gt;= &lt;=</li>
<li>instanceof</li>
<li>组合 ()</li>
<li>迭代 - character, String, numeric, null</li>
<li>强制转换</li>
<li>方法调用</li>
<li>字段访问</li>
<li>数组调用</li>
<li>三目运算符 ?:</li>
</ul>
<p>使用范例<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:text="@&#123;String.valueOf(index + 1)&#125;"</div><div class="line">android:visibility="@&#123;age &amp;lt; 13 ? View.GONE : View.VISIBLE&#125;"</div><div class="line">android:transitionName='@&#123;"image_" + id&#125;'</div></pre></td></tr></table></figure></p>
<p>2）不支持特性</p>
<ul>
<li><code>不支持</code>Java 中 的this, super，new 操作符</li>
</ul>
<p>3）空聚合操作符<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:text="@&#123;user.displayName ?? user.lastName&#125;"</div></pre></td></tr></table></figure></p>
<p>与三目运算符<code>?:</code>相同<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:text="@&#123;user.displayName != null ? user.displayName : user.lastName&#125;"</div></pre></td></tr></table></figure></p>
<p>4）属性引用<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:text="@&#123;user.lastName&#125;"</div></pre></td></tr></table></figure></p>
<p>5）可以避免空指针<br>Data Binding自动检查null对象，避免空指针。如：@{user.name}, 如果user为空，则user.name为<br>默认值null。类似的user.age为0</p>
<p>6）集合<br>常用集合:arrays, lists, sparse lists, and maps。可以用[]操作符。<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.util.SparseArray"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.Map"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.List"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">type</span>=<span class="string">"List&lt;String&gt;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"sparse"</span> <span class="attr">type</span>=<span class="string">"SparseArray&lt;String&gt;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"map"</span> <span class="attr">type</span>=<span class="string">"Map&amp;lt&lt;String, String&gt;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">…</div><div class="line">android:text="@&#123;list[index]&#125;"</div><div class="line">…</div><div class="line">android:text="@&#123;sparse[index]&#125;"</div><div class="line">…</div><div class="line">android:text="@&#123;map[key]&#125;"</div></pre></td></tr></table></figure></p>
<p>7）引用String值<br>如果属性使用单引号，则表达式使用双引号<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:text='@&#123;map["firstName"]&#125;'</div></pre></td></tr></table></figure></p>
<p>如果属性使用双引号，String值使用单引号 或 双引号<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:text="@&#123;map[`firstName`&#125;"</div><div class="line">android:text="@&#123;map["firstName"]&#125;"</div></pre></td></tr></table></figure></p>
<p>8）引用资源文件<br>使用正常资源访问语法<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 访问资源 --&gt;</span></div><div class="line">android:padding="@&#123;large? @dimen/largePadding : @dimen/smallPadding&#125;"</div></pre></td></tr></table></figure></p>
<p>根据String资源格式化字符串和复数。<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">android:text="@&#123;@string/nameFormat(firstName, lastName)&#125;"</div><div class="line">android:text="@&#123;@plurals/banana(bananaCount)&#125;"</div></pre></td></tr></table></figure></p>
<p>带有多个参数的复数，应该传递所有参数。<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">  Have an orange</div><div class="line">  Have %d oranges</div><div class="line"></div><div class="line">android:text="@&#123;@plurals/orange(orangeCount, orangeCount)&#125;"</div></pre></td></tr></table></figure></p>
<p>需要明确的一些资源类型</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Normal Reference</th>
<th>Expression Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td>String[]</td>
<td>@array</td>
<td>@stringArray</td>
</tr>
<tr>
<td>int[]</td>
<td>@array</td>
<td>@intArray</td>
</tr>
<tr>
<td>TypedArray</td>
<td>@array</td>
<td>@typedArray</td>
</tr>
<tr>
<td>Animator</td>
<td>@animator</td>
<td>@animator</td>
</tr>
<tr>
<td>StateListAnimator</td>
<td>@animator</td>
<td>@stateListAnimator</td>
</tr>
<tr>
<td>color int</td>
<td>@color</td>
<td>@color</td>
</tr>
<tr>
<td>ColorStateList</td>
<td>@color</td>
<td>@colorStateList</td>
</tr>
</tbody>
</table>
<h2 id="五、Data对象"><a href="#五、Data对象" class="headerlink" title="五、Data对象"></a>五、Data对象</h2><p>旧式Java POJO可以用做数据绑定，但是修改数据时不能更新UI。而真正的Data Binding在数据变化时能够来修改。<br>有三种不同的数据变化通机制。<a href="https://developer.android.com/topic/libraries/data-binding/index.html#observable_objects" target="_blank" rel="external">Observable objects</a>、<a href="https://developer.android.com/topic/libraries/data-binding/index.html#observablefields" target="_blank" rel="external">observable fields</a>、<a href="https://developer.android.com/topic/libraries/data-binding/index.html#observable_collections" target="_blank" rel="external">observable collection</a>。当这些可观察的数据对象绑定UI后，在data对象属性值变化时，会自动更新UI。</p>
<h3 id="1-可观察对象（Observable-Object）"><a href="#1-可观察对象（Observable-Object）" class="headerlink" title="1. 可观察对象（Observable Object）"></a>1. 可观察对象（Observable Object）</h3><p>实现<a href="https://developer.android.com/reference/android/databinding/Observable.html" target="_blank" rel="external">Observable</a>接口的类可以绑定一个单独的Listener来监听对象属性值的变化。<a href="https://developer.android.com/reference/android/databinding/Observable.html" target="_blank" rel="external">Observable</a>接口提供了添加和移除监听的机制。<a href="https://developer.android.com/reference/android/databinding/BaseObservable.html" target="_blank" rel="external">BaseObservable</a>就是实现了Observable的监听注册机制的基类。为了能够让data数据对象在属性值变化时发出通知，可以通过为属性值的getter方法设定<a href="https://developer.android.com/reference/android/databinding/Bindable.html" target="_blank" rel="external">Bindable</a>注解并在setter方法中添加通知。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> String firstName;</div><div class="line">   <span class="keyword">private</span> String lastName;</div><div class="line">   <span class="meta">@Bindable</span></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Bindable</span></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.firstName = firstName;</div><div class="line">       notifyPropertyChanged(BR.firstName);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.lastName = lastName;</div><div class="line">       notifyPropertyChanged(BR.lastName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编译时<a href="https://developer.android.com/reference/android/databinding/Bindable.html" target="_blank" rel="external">Bindable</a>注解会在BR类中生成对应的访问入口。BR类会在编译时自动在module中生成。如果<br>无法修改data类的基类，可以使用<a href="https://developer.android.com/reference/android/databinding/PropertyChangeRegistry.html" target="_blank" rel="external">PropertyChangeRegistry</a>实现<a href="https://developer.android.com/reference/android/databinding/Observable.html" target="_blank" rel="external">Observable</a>接口，更高效存储和通知监听。</p>
<h3 id="2-可观察字段（ObservableFields）"><a href="#2-可观察字段（ObservableFields）" class="headerlink" title="2. 可观察字段（ObservableFields）"></a>2. 可观察字段（ObservableFields）</h3><p>如果仅有少量属性值或为了节省时间可以使用<a href="https://developer.android.com/reference/android/databinding/ObservableField.html" target="_blank" rel="external">ObservableField</a>来创建<a href="https://developer.android.com/reference/android/databinding/Observable.html" target="_blank" rel="external">Observable</a>类。与ObservableField类似的还有<a href="https://developer.android.com/reference/android/databinding/ObservableBoolean.html" target="_blank" rel="external">ObservableBoolean</a>, <a href="https://developer.android.com/reference/android/databinding/ObservableByte.html" target="_blank" rel="external">ObservableByte</a>, <a href="https://developer.android.com/reference/android/databinding/ObservableChar.html" target="_blank" rel="external">ObservableChar</a>, <a href="https://developer.android.com/reference/android/databinding/ObservableShort.html" target="_blank" rel="external">ObservableShort</a>, <a href="https://developer.android.com/reference/android/databinding/ObservableInt.html" target="_blank" rel="external">ObservableInt</a>,<br><a href="https://developer.android.com/reference/android/databinding/ObservableLong.html" target="_blank" rel="external">ObservableLong</a>, <a href="https://developer.android.com/reference/android/databinding/ObservableFloat.html" target="_blank" rel="external">ObservableFloat</a>, <a href="https://developer.android.com/reference/android/databinding/ObservableDouble.html" target="_blank" rel="external">ObservableDouble</a>和<a href="https://developer.android.com/reference/android/databinding/ObservableParcelable.html" target="_blank" rel="external">ObservableParcelable</a>。ObservableFields是独立的可观察对象。使用基本数据类型可以避免封箱和拆箱操作。使用时需要在数据类中创建<code>public final</code>属性的字段<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">   <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName =</div><div class="line">       <span class="keyword">new</span> ObservableField&lt;&gt;();</div><div class="line">   <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName =</div><div class="line">       <span class="keyword">new</span> ObservableField&lt;&gt;();</div><div class="line">   <span class="keyword">public</span> <span class="keyword">final</span> ObservableInt age = <span class="keyword">new</span> ObservableInt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用set和get方法来存取属性值。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">user.firstName.set(<span class="string">"Google"</span>);</div><div class="line"><span class="keyword">int</span> age = user.age.get();</div></pre></td></tr></table></figure></p>
<h3 id="3-可观察集合（Observable-Collections）"><a href="#3-可观察集合（Observable-Collections）" class="headerlink" title="3. 可观察集合（Observable Collections）"></a>3. 可观察集合（Observable Collections）</h3><p>一些应用需要使用动态接口（如Map）来保存数据。Observable Collections可以通过键（key）来存取集合中的对象。如在键值为引用类型时，可以使用<a href="https://developer.android.com/reference/android/databinding/ObservableArrayMap.html" target="_blank" rel="external">ObservableArrayMap</a>。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ObservableArrayMap&lt;String, Object&gt; user = <span class="keyword">new</span> ObservableArrayMap&lt;&gt;();</div><div class="line">user.put(<span class="string">"firstName"</span>, <span class="string">"Google"</span>);</div><div class="line">user.put(<span class="string">"lastName"</span>, <span class="string">"Inc."</span>);</div><div class="line">user.put(<span class="string">"age"</span>, <span class="number">17</span>);</div></pre></td></tr></table></figure></p>
<p>在布局文件中 可以通过key来访问map中对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.databinding.ObservableMap"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"ObservableMap&lt;String, Object&gt;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">'@&#123;user["lastName"]&#125;'</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">'@&#123;String.valueOf(1 + (Integer)user["age"])&#125;'</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure>
<p>如果使用整型作为键值时，可以考虑使用<a href="https://developer.android.com/reference/android/databinding/ObservableArrayList.html" target="_blank" rel="external">ObservableArrayList</a><br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ObservableArrayList&lt;Object&gt; user = <span class="keyword">new</span> ObservableArrayList&lt;&gt;();</div><div class="line">user.add(<span class="string">"Google"</span>);</div><div class="line">user.add(<span class="string">"Inc."</span>);</div><div class="line">user.add(<span class="number">17</span>);</div></pre></td></tr></table></figure></p>
<p>在布局中使用索引来访问list集合<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.databinding.ObservableList"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.my.app.Fields"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"ObservableList&lt;Object&gt;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">'@&#123;user[Fields.LAST_NAME]&#125;'</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">'@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;'</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h2 id="六、生成的Binding类"><a href="#六、生成的Binding类" class="headerlink" title="六、生成的Binding类"></a>六、生成的Binding类</h2><p>生成的Binding能够通过layout中的Views对象连接布局变量。如上所述，Binding类的命名和包名可以<a href="https://developer.android.com/topic/libraries/data-binding/index.html#custom_binding_class_names" target="_blank" rel="external">自定义</a>，生成的Binding类都继承自<a href="https://developer.android.com/reference/android/databinding/ViewDataBinding.html" target="_blank" rel="external">ViewDataBinding</a>。</p>
<h3 id="1-创建Binding类对象"><a href="#1-创建Binding类对象" class="headerlink" title="1. 创建Binding类对象"></a>1. 创建Binding类对象</h3><p>Binding类对象应该在inflate视图之后尽快创建，保证在表达式绑定View时，View Hierarchy不会被干扰。绑定布局文件有不同方式，最常用是用Binding类的静态方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflate);</div><div class="line"><span class="comment">// 或者</span></div><div class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflate , viewGroup , <span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<p>如果布局使用其他方式inflate，则需要分开来完成绑定。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);</div></pre></td></tr></table></figure></p>
<p>有时不能预先知道binding。在这些情况可以使用<a href="https://developer.android.com/reference/android/databinding/DataBindingUtil.html" target="_blank" rel="external">DataBindingUtil</a>类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId,</div><div class="line">    parent, attachToParent);</div><div class="line">ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId);</div></pre></td></tr></table></figure></p>
<h3 id="2-使用ID的View"><a href="#2-使用ID的View" class="headerlink" title="2. 使用ID的View"></a>2. 使用ID的View</h3><p>当为View指定一个ID时，则会在Binding类中为View生成一个<code>public final</code>属性的字段，直接获取View，比通过调用findViewById更加快速。如<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span></div><div class="line">           <span class="attr">android:id</span>=<span class="string">"@+id/firstName"</span>/&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span></div><div class="line">  <span class="attr">android:id</span>=<span class="string">"@+id/lastName"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>则会在Binding类中生成如下的字段<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> TextView firstName;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> TextView lastName;</div></pre></td></tr></table></figure></p>
<p>对于data binding来说 ID几乎没有必要，但是在需要在代码中来获取view实例时仍有必要。</p>
<h3 id="3-Variables变量"><a href="#3-Variables变量" class="headerlink" title="3. Variables变量"></a>3. Variables变量</h3><p>会为布局中每个声明的变量生成getter和setter方法的。<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.graphics.drawable.Drawable"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span>  <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"image"</span> <span class="attr">type</span>=<span class="string">"Drawable"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"note"</span>  <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>会在Binding类中生成如下方法<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> com.example.<span class="function">User <span class="title">getUser</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(com.example.User user)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Drawable <span class="title">getImage</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setImage</span><span class="params">(Drawable image)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getNote</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNote</span><span class="params">(String note)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="4-ViewStubs布局"><a href="#4-ViewStubs布局" class="headerlink" title="4. ViewStubs布局"></a>4. ViewStubs布局</h3><p><a href="https://developer.android.com/reference/android/view/ViewStub.html" target="_blank" rel="external">ViewStub</a>与常用View有些不同：起始时不可见，<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/stub"</span></span></div><div class="line">    <span class="attr">android:inflatedId</span>=<span class="string">"@+id/subTree"</span></div><div class="line">    <span class="attr">android:layout</span>=<span class="string">"@layout/mySubTree"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"120dip"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"40dip"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>用setVisiable变为可见或显式调用inflate时，则用android:layout中的定义布局替换自己与<code>include</code>类似。但与<code>include</code>不同的的是在初始时并不会inflate到布局文件中，所以Binding的view不会在初始化时完成绑定。因为Binding中的View为final属性，使用<a href="https://developer.android.com/reference/android/databinding/ViewStubProxy.html" target="_blank" rel="external">ViewStubProxy</a>代理对象来替代ViewStud，可以在ViewStud创建后来访问。同样在ViewStud被inflate时，能够访问inflated的View Hierarchy。当inflate ViewStud的布局时，必须为新布局建立Binding。因此ViewStubProxy必须监听<a href="https://developer.android.com/reference/android/view/ViewStub.OnInflateListener.html" target="_blank" rel="external">ViewStub.OnInflateListener</a>并在inflate时建立Binding。又因为只能有一个存在，ViewStubProxy在创建Binding类对象后调用OnInflateListener。</p>
<h2 id="七、高级Binding"><a href="#七、高级Binding" class="headerlink" title="七、高级Binding"></a>七、高级Binding</h2><h3 id="1-动态变量"><a href="#1-动态变量" class="headerlink" title="1. 动态变量"></a>1. 动态变量</h3><p>有时不知道指定的Binding类。如： 操作不同布局的<a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" target="_blank" rel="external">RecyclerView.Adapter</a>不知道指定的Binding类，但必须要在<a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html#onBindViewHolder(VH, int" target="_blank" rel="external">onBindViewHolder(VH , int)</a>)<br>中关联Binding值。<br>例子中所有RecyclerView绑定的布局都有一个item变量。BindingHolder有一个getBinding方法返回<a href="https://developer.android.com/reference/android/databinding/ViewDataBinding.html" target="_blank" rel="external">ViewDataBinding</a>基类。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(BindingHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> T item = mItems.get(position);</div><div class="line">   holder.getBinding().setVariable(BR.item, item);</div><div class="line">   holder.getBinding().executePendingBindings();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-立即绑定"><a href="#2-立即绑定" class="headerlink" title="2. 立即绑定"></a>2. 立即绑定</h3><p>当变量或观察者变化时，Binding在下一帧前执行改变操作。有时Binding必须立即执行。强制执行使用 <a href="https://developer.android.com/reference/android/databinding/ViewDataBinding.html#executePendingBindings(" target="_blank" rel="external">executePendingBindings()</a>)方法</p>
<h3 id="3-后台线程"><a href="#3-后台线程" class="headerlink" title="3. 后台线程"></a>3. 后台线程</h3><p>DataBinding可以在后台线程中修改非集合类型的data数据，在线程中执行时，DataBinding会本地化变量和字段，避免多线程引起的同步问题。</p>
<h2 id="七、属性Setter"><a href="#七、属性Setter" class="headerlink" title="七、属性Setter"></a>七、属性Setter</h2><p>无论何时绑定值变化，生成的binding类都必须view中绑定的表达式setter方法。DataBinding框架能够自定义setter的方法。</p>
<h3 id="1-自动setter"><a href="#1-自动setter" class="headerlink" title="1. 自动setter"></a>1. 自动setter</h3><p>对于属性attribute来说，DataBinding会尝试查找setAttribute方法。attribute的命名空间可以或略，只针对属性的名称。如：关联TextView的android:text属性表达式会查找setText方法。如果表达式返回int，DataBinding会搜索setText(int)的方法。注意要用返回正确类型的表达式，如果必要的话，使用强制类型转换。</p>
<blockquote>
<p>注：即使不存在指定的属性名，DataBinding也会工作。</p>
</blockquote>
<p>你可以使用DataBinding为任意setter方法创建对应的属性名。如：依赖库DrawerLayout没有任何属性名，但是仍有很多setter，可以使用自动的属性名setter方法<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">app:scrimColor</span>=<span class="string">"@&#123;@color/scrim&#125;"</span></div><div class="line">    <span class="attr">app:drawerListener</span>=<span class="string">"@&#123;fragment.drawerListener&#125;"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="2-setter重命名"><a href="#2-setter重命名" class="headerlink" title="2. setter重命名"></a>2. setter重命名</h3><p>有点setter方法没有对应的属性名。对于这些方法，可以用<a href="https://developer.android.com/reference/android/databinding/BindingMethods.html" target="_blank" rel="external">BindingMethods</a>注解关联指定的属性名，使用这种方式时必须关联用<a href="https://developer.android.com/reference/android/databinding/BindingMethod.html" target="_blank" rel="external">BindingMethods</a>注解的类。如<code>android:tint</code>属性名实际关联的是<a href="https://developer.android.com/reference/android/widget/ImageView.html#setImageTintList(android.content.res.ColorStateList" target="_blank" rel="external">setImageTintList(ColorStateList)</a>)方法而不是<code>setTint()</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@BindingMethods</span>(&#123;</div><div class="line">       <span class="meta">@BindingMethod</span>(type = <span class="string">"android.widget.ImageView"</span>,</div><div class="line">                      attribute = <span class="string">"android:tint"</span>,</div><div class="line">                      method = <span class="string">"setImageTintList"</span>),</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>一般来说没有必要重命名setters，因为android框架属性已经实现。</p>
<h3 id="3-自定义setter"><a href="#3-自定义setter" class="headerlink" title="3. 自定义setter"></a>3. 自定义setter</h3><p>有时需要自定义属性的绑定逻辑。如：<code>android:paddingLeft</code>没有对应的setter实现方法，但是存在<code>setPadding(left, top, right, bottom)</code>方法。使用<code>BindingAdapter</code>注解的静态方法可以用来自定义属性名的setter逻辑。<br>android属性已经有创建的<a href="https://developer.android.com/reference/android/databinding/BindingAdapter.html" target="_blank" rel="external">BindingAdapter</a>，如： paddingLeft<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:paddingLeft"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPaddingLeft</span><span class="params">(View view, <span class="keyword">int</span> padding)</span> </span>&#123;</div><div class="line">   view.setPadding(padding,</div><div class="line">                   view.getPaddingTop(),</div><div class="line">                   view.getPaddingRight(),</div><div class="line">                   view.getPaddingBottom());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BindingAdapter对自定义类型的属性很有用。如：创建图片加载方法。</p>
<blockquote>
<p>注：当默认的Adapter与自定义的BindingAdapter冲突时，自定义的BindingAdapter覆盖默认值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 1. 全部满足</span></div><div class="line"><span class="meta">@BindingAdapter</span>(&#123;<span class="string">"bind:imageUrl"</span>, <span class="string">"bind:error"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> </span>&#123;</div><div class="line">   Picasso.with(view.getContext()).load(url).error(error).into(view);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2. 满足其中一个时</span></div><div class="line"><span class="meta">@BindingAdapter</span>(value = &#123;<span class="string">"bind:imageUrl"</span>, <span class="string">"bind:error"</span>&#125; , requireAll = <span class="keyword">false</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> </span>&#123;</div><div class="line">   Picasso.with(view.getContext()).load(url).error(error).into(view);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Layout</span></div><div class="line">&lt;ImageView app:imageUrl=<span class="string">"@&#123;venue.imageUrl&#125;"</span></div><div class="line">app:error=<span class="string">"@&#123;@drawable/venueError&#125;"</span>/&gt;</div></pre></td></tr></table></figure>
<p>使用第一种BindingAdapter时，必须要同时声明<code>bind:imageUrl</code>和<code>bind:error</code>两个属性时，才会调用。</p>
<ul>
<li>在属性名匹配BindingAdapter时，自动会忽略属性名之前的命名空间</li>
<li>可以自定义以android为命名空间的属性值（此时自定义覆盖默认）。</li>
</ul>
<p>BindingAdapter可以用在处理方法中使用旧值。如：在新值与旧值不同时，使用新值。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:paddingLeft"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPaddingLeft</span><span class="params">(View view, <span class="keyword">int</span> oldPadding, <span class="keyword">int</span> newPadding)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (oldPadding != newPadding) &#123;</div><div class="line">       view.setPadding(newPadding,</div><div class="line">                       view.getPaddingTop(),</div><div class="line">                       view.getPaddingRight(),</div><div class="line">                       view.getPaddingBottom());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事件处理器可以使用接口类或带有一个抽象方法的抽象类作为参数。如<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:onLayoutChange"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setOnLayoutChangeListener</span><span class="params">(View view, View.OnLayoutChangeListener oldValue,</span></span></div><div class="line">       View.OnLayoutChangeListener newValue) &#123;</div><div class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">        <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</div><div class="line">            view.removeOnLayoutChangeListener(oldValue);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</div><div class="line">            view.addOnLayoutChangeListener(newValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当Listener有多个方法时，必须拆分成多个Listener。如：<a href="https://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html" target="_blank" rel="external">View.OnAttachStateChangeListener</a>有两个方法<br><a href="https://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html#onViewAttachedToWindow(android.view.View" target="_blank" rel="external">onViewAttachedToWindow()</a>) 和 <a href="https://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html#onViewDetachedFromWindow(android.view.View" target="_blank" rel="external">onViewDetachedFromWindow()</a>)。我们必须创建两个接口来区分属性和处理方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@TargetApi</span>(VERSION_CODES.HONEYCOMB_MR1)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnViewDetachedFromWindow</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@TargetApi</span>(VERSION_CODES.HONEYCOMB_MR1)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnViewAttachedToWindow</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为修改一个Listener可能会影响到其他的Listener，所以必须要创建三个不同的BindingAdapter<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:onViewAttachedToWindow"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">(View view, OnViewAttachedToWindow attached)</span> </span>&#123;</div><div class="line">    setListener(view, <span class="keyword">null</span>, attached);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:onViewDetachedFromWindow"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">(View view, OnViewDetachedFromWindow detached)</span> </span>&#123;</div><div class="line">    setListener(view, detached, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@BindingAdapter</span>(&#123;<span class="string">"android:onViewDetachedFromWindow"</span>, <span class="string">"android:onViewAttachedToWindow"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">(View view, <span class="keyword">final</span> OnViewDetachedFromWindow detach,</span></span></div><div class="line">        <span class="keyword">final</span> OnViewAttachedToWindow attach) &#123;</div><div class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;</div><div class="line">        <span class="keyword">final</span> OnAttachStateChangeListener newListener;</div><div class="line">        <span class="keyword">if</span> (detach == <span class="keyword">null</span> &amp;&amp; attach == <span class="keyword">null</span>) &#123;</div><div class="line">            newListener = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            newListener = <span class="keyword">new</span> OnAttachStateChangeListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (attach != <span class="keyword">null</span>) &#123;</div><div class="line">                        attach.onViewAttachedToWindow(v);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (detach != <span class="keyword">null</span>) &#123;</div><div class="line">                        detach.onViewDetachedFromWindow(v);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view,</div><div class="line">                newListener, R.id.onAttachStateChangeListener);</div><div class="line">        <span class="keyword">if</span> (oldListener != <span class="keyword">null</span>) &#123;</div><div class="line">            view.removeOnAttachStateChangeListener(oldListener);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (newListener != <span class="keyword">null</span>) &#123;</div><div class="line">            view.addOnAttachStateChangeListener(newListener);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子稍微复杂一些，因为View使用添加和移除Listener方式，而不是为<a href="https://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html" target="_blank" rel="external">View.OnAttachStateChangeListener</a>设置<br>setter方法。android.databinding.adapters.ListenerUtil类帮助跟踪之前的Listener，这样他们可以在<br>Binding适配器中移除旧的Listener。<br>通过 @TargetApi(VERSION_CODES.HONEYCOMB_MR1)注解接口OnViewDetachedFromWindow和OnViewAttachedToWindow，DataBinding代码生成器就会知道只有运行 Honeycomb MR1版本及以上的新设备才生成Listener。</p>
<h2 id="八、转换器Converters"><a href="#八、转换器Converters" class="headerlink" title="八、转换器Converters"></a>八、转换器Converters</h2><h3 id="1-对象转换"><a href="#1-对象转换" class="headerlink" title="1. 对象转换"></a>1. 对象转换</h3><p>如果是表达式返回的对象，则会从自动的、重命名或自定义的setter方法中选择一个setter方法。对象会强转成适合setter方法中参数类型。这种方式适合用ObservableMaps来保存数据的布局，如：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">'@&#123;userMap["lastName"]&#125;'</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p><code>userMap</code>返回的对象自动强转为<code>setText(CharSequence)</code>中参数类型。当setter方法的参数类型存在二义性时，如存在两个setter方法，但是参数不一样时，需要使用手动强转。</p>
<h3 id="2-自定义转换"><a href="#2-自定义转换" class="headerlink" title="2. 自定义转换"></a>2. 自定义转换</h3><p>有时需要让布局在指定类型之前自动转换，如设置背景时<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">View</span></span></div><div class="line">   <span class="attr">android:background</span>=<span class="string">"@&#123;isError ? @color/red : @color/white&#125;"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>这里android:background的setter方法参数类型为<code>Drawable</code>，但是Color是整型。可以将整型的color转为Drawable类型的<code>ColorDrawable</code>，通过BindingConversion注解的静态方法来实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@BindingConversion</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ColorDrawable <span class="title">convertColorToDrawable</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ColorDrawable(color);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：转换器只在setter层执行，禁止使用混合类型。如：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">View</span></span></div><div class="line">   <span class="attr">android:background</span>=<span class="string">"@&#123;isError ? @drawable/error : @color/white&#125;"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="九、Android-Studio对Data-Binding的支持"><a href="#九、Android-Studio对Data-Binding的支持" class="headerlink" title="九、Android Studio对Data Binding的支持"></a>九、Android Studio对Data Binding的支持</h2><p> Android Studio支持很多data binding代码的编辑特性。如</p>
<ul>
<li>语法高亮</li>
<li>标记表达式语法错误。</li>
<li>XML代码补全</li>
<li>引用包括导航和快速文档</li>
</ul>
<blockquote>
<p>注：Arrays和<a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" target="_blank" rel="external">生成类型</a>如<a href="https://developer.android.com/reference/android/databinding/Observable.html" target="_blank" rel="external">Observable</a>类，可能会出现显示错误（实际上没有错误）<br> 预览窗口显示data binding的默认值。如：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">  <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName, default=PLACEHOLDER&#125;"</span>/&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<p> 预览窗口会显示PLACEHOLDER作为TextView默认值。<br> 如果需要在项目设计时显示默认值，可以使用tools属性替代默认的表达式。具体见<a href="http://tools.android.com/tips/layout-designtime-attributes" target="_blank" rel="external">Designtime Layout Attributes</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">Data Binding Library</a></p>
<p><a href="https://realm.io/cn/news/data-binding-android-boyar-mount/" target="_blank" rel="external">棉花糖给 Android 带来的 Data Bindings</a></p>
<p><a href="https://halfthought.wordpress.com/2016/03/23/2-way-data-binding-on-android/" target="_blank" rel="external">2-way Data Binding on Android</a></p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/07/22/Android：Service与Notification/" data-toggle="tooltip" data-placement="top" title="Android：Notification基础">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/06/28/Android：Handler、Message、MessageQueue、Looper/" data-toggle="tooltip" data-placement="top" title="Android：Handler、Message、MessageQueue、Looper">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#android-mvvm" title="android-mvvm">android-mvvm</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "alexwan02";
    var disqus_identifier = "http://blog.alexwan.cn/2016/07/17/Android：DataBinding-Guide/";
    var disqus_url = "http://blog.alexwan.cn/2016/07/17/Android：DataBinding-Guide/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/alexwan02">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/alexwan02">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Alex Studio 2017 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://blog.alexwan.cn/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="http://blog.alexwan.cn/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Kotlin进阶之与Java交互 - Alex Studio
        
    </title>

    <link rel="canonical" href="http://blog.alexwan.cn/2017/07/18/Kotlin进阶之与Java交互/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Alex Studio</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://blog.alexwan.cn/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#kotlin" title="kotlin">kotlin</a>
                        
                    </div>
                    <h1>Kotlin进阶之与Java交互</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by AlexWan on
                        2017-07-18
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="Kotlin调用Java"><a href="#Kotlin调用Java" class="headerlink" title="Kotlin调用Java"></a>Kotlin调用Java</h1><p>Kotlin可以自然地调用Java代码，同样Java也可以丝滑般调用Kotlin代码。这节详细描述kotlin调用Java代码。</p>
<p>可以使用几乎所有Java代码。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(source: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> list = ArrayList&lt;<span class="built_in">Int</span>&gt;()</div><div class="line">    <span class="comment">// 'for'-loops work for Java collections:</span></div><div class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</div><div class="line">        list.add(item)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Operator conventions work as well:</span></div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.source.size() - <span class="number">1</span>) &#123;</div><div class="line">        list[i] = source[i] <span class="comment">// get and set are called</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Getters和Setters"><a href="#Getters和Setters" class="headerlink" title="Getters和Setters"></a>Getters和Setters</h2><p>按照Java约定<code>getter</code>和<code>setter</code>方法作为Kotlin的属性。<code>Boolean</code>访问者方法（getter方法以<code>is</code>开头，setter以<code>set</code>开头）属性与getter方法名相同。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Calendar</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calendarDemo</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> calendar = Calendar.getInstance()</div><div class="line">    <span class="keyword">if</span> (calendar.firstDayOfWeek == Calendar.SUNDAY) &#123;  <span class="comment">// call getFirstDayOfWeek()</span></div><div class="line">        calendar.firstDayOfWeek = Calendar.MONDAY       <span class="comment">// call setFirstDayOfWeek()</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果Java类只有一个setter方法，则在Kotlin中不能视为属性。因为Kotlin现在不支持只有set的属性。</p>
</blockquote>
<h2 id="返回void的方法"><a href="#返回void的方法" class="headerlink" title="返回void的方法"></a>返回void的方法</h2><p>如果Java方法返回void，则在Kotlin中返回<code>Unit</code>。万一使用了返回值，则Kotlin编译器在调用处对其赋值（Unit）。</p>
<h2 id="对Kotlin中的关键字的Java标识符的转义"><a href="#对Kotlin中的关键字的Java标识符的转义" class="headerlink" title="对Kotlin中的关键字的Java标识符的转义"></a>对Kotlin中的关键字的Java标识符的转义</h2><p>Kotlin中一些关键字（如<code>in</code>、<code>object</code>、<code>is</code>等）是Java的标识符。如果Java库中方法使用Kotlin关键字，人可以使用(==`==)转义：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line">foo.`<span class="keyword">is</span>`(bar)</div></pre></td></tr></table></figure></p>
<h2 id="空安全与平台类型"><a href="#空安全与平台类型" class="headerlink" title="空安全与平台类型"></a>空安全与平台类型</h2><p>Java中任何引用都可能为<code>null</code>，让Kotlin空安全严格的需求不适应于Java中的对象。Kotlin特殊对待Java声明的类型，称其为<code>平台类型</code>。对这些类型，空检查不那么严格，所以它们的安全保证与在Java一样</p>
<p>假设以下方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;() <span class="comment">// 非空</span></div><div class="line">list.add(<span class="string">"Item"</span>)</div><div class="line"><span class="keyword">val</span> size = list.size()         <span class="comment">// 非空（原始int）</span></div><div class="line"><span class="keyword">val</span> item = list[<span class="number">0</span>]            <span class="comment">//  平台类型推断（原始Java对象）</span></div></pre></td></tr></table></figure></p>
<p>当在调用平台类型变量的方法时，Kotlin不会在编译时报错，但是在运行时可能会出错。因为空指针或Kotlin生成的断言禁止传播空值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line">items.substring(<span class="number">1</span>) <span class="comment">// 允许，如果item == null 时抛出异常</span></div></pre></td></tr></table></figure>
<p>平台类型是不可表示的，意味着无法在语言中明确指明。当给Kotlin变量赋值平台时，依赖类型推断，或者选择期望的类型（非空和可空类型都允许）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> nullable: String? = item  <span class="comment">// 允许</span></div><div class="line"><span class="keyword">val</span> notNull: String = item    <span class="comment">// 允许，运行时可能出错</span></div></pre></td></tr></table></figure>
<p>如果选择非空类型，编译器会在赋值上生成一个断言。保证Kotlin非空类型持有空值，当将平台类型值传给期望非空类型值的函数时，也会生成断言。以上，编译尽可能控制<code>空值</code>在程序中传播（尽管因为泛型，不能够完全消除空值）</p>
<h3 id="平台类型标记"><a href="#平台类型标记" class="headerlink" title="平台类型标记"></a>平台类型标记</h3><p>如上所述，平台类型无法在程序中显示标记，所以语言中没有相关的语法。不过，编译器和IDE有时需要显示这些类型（错误信息，参数信息等等），所以Kotlin提供了一些助记符</p>
<ul>
<li><code>T!</code>表示<code>T</code> 或<code>T?</code></li>
<li><code>(Mutable)Collection&lt;T&gt;!</code>表示类型为<code>T</code>的Java集合可变或不变，可能为空或不为空</li>
<li><code>Array&lt;(out) T&gt;!</code>表示类型为<code>T</code>或<code>T的子类</code>的Java集合，可以为空或不为空</li>
</ul>
<h3 id="可空性注解"><a href="#可空性注解" class="headerlink" title="可空性注解"></a>可空性注解</h3><p>有可空性注解的Java类型不会作为平台类型处理，而是实际的可为空或非空的Kotlin类型。编译器支持以下几种可空性注解</p>
<ul>
<li><a href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html" target="_blank" rel="external">JetBrains</a>（<code>@Nullable</code>和<code>@NotNull</code>）</li>
<li>Android（<code>com.android.annotations</code>和<code>android.support.annotations</code>）</li>
<li>JSR-305（<code>javax.annotation</code>）</li>
<li>FindBugs（<code>edu.umd.cs.findbugs.annotations</code>）</li>
<li>Eclipse（<code>org.eclipse.jdt.annotation</code>）</li>
<li>Lombok（<code>lombok.NonNull</code>）</li>
</ul>
<p><a href="https://github.com/JetBrains/kotlin/blob/master/core/descriptor.loader.java/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt" target="_blank" rel="external">Kotlin编译器源码</a>提供完整列表</p>
<h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>Kotlin对Java一些类型特殊对待，并不照样加载，而是映射成Kotlin对应的类型。映射只在编译时进行，不影响运行时。</p>
<p>Java的基本类型映射为对应的Kotlin类型（牢记<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types" target="_blank" rel="external">平台类型</a>）</p>
<table>
<thead>
<tr>
<th>Java type</th>
<th>Kotlin type</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>kotlin.Byte</td>
</tr>
<tr>
<td>short</td>
<td>kotlin.Short</td>
</tr>
<tr>
<td>int</td>
<td>kotlin.Int</td>
</tr>
<tr>
<td>long</td>
<td>kotlin.Long</td>
</tr>
<tr>
<td>char</td>
<td>kotlin.Char</td>
</tr>
<tr>
<td>float</td>
<td>kotlin.Float</td>
</tr>
<tr>
<td>double</td>
<td>kotlin.Double</td>
</tr>
<tr>
<td>boolean</td>
<td>kotlin.Boolean</td>
</tr>
</tbody>
</table>
<p>非基本类型的固定类</p>
<table>
<thead>
<tr>
<th>Java type</th>
<th>Kotlin type</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang.Object</td>
<td>kotlin.Any!</td>
</tr>
<tr>
<td>java.lang.Cloneable</td>
<td>kotlin.Cloneable!</td>
</tr>
<tr>
<td>java.lang.Comparable</td>
<td>kotlin.Comparable!</td>
</tr>
<tr>
<td>java.lang.Enum</td>
<td>kotlin.Enum!</td>
</tr>
<tr>
<td>java.lang.Annotation</td>
<td>kotlin.Annotation!</td>
</tr>
<tr>
<td>java.lang.Deprecated</td>
<td>kotlin.Deprecated!</td>
</tr>
<tr>
<td>java.lang.CharSequence</td>
<td>kotlin.CharSequence!</td>
</tr>
<tr>
<td>java.lang.String</td>
<td>kotlin.String!</td>
</tr>
<tr>
<td>java.lang.Number</td>
<td>kotlin.Number!</td>
</tr>
<tr>
<td>java.lang.Throwable</td>
<td>kotlin.Throwable!</td>
</tr>
</tbody>
</table>
<p>Java装箱的基本类型映射为Kotlin的可空类型</p>
<table>
<thead>
<tr>
<th>Java type</th>
<th>Kotlin type</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang.Byte</td>
<td>kotlin.Byte?</td>
</tr>
<tr>
<td>java.lang.Short</td>
<td>kotlin.Short?</td>
</tr>
<tr>
<td>java.lang.Integer</td>
<td>kotlin.Int?</td>
</tr>
<tr>
<td>java.lang.Long</td>
<td>kotlin.Long?</td>
</tr>
<tr>
<td>java.lang.Character</td>
<td>kotlin.Char?</td>
</tr>
<tr>
<td>java.lang.Float</td>
<td>kotlin.Float?</td>
</tr>
<tr>
<td>java.lang.Double</td>
<td>kotlin.Double?</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>kotlin.Boolean?</td>
</tr>
</tbody>
</table>
<blockquote>
<p>装箱的私有类型可作为映射为平台类型的类型参数：如<code>List&lt;java.lang.Integer&gt;</code>在Kotlin中变为<code>List&lt;Int!&gt;</code></p>
</blockquote>
<p>集合类型在Kotlin变为<code>只读</code>或<code>可变</code>，所以Java类型按照下面规则进行映射（表中所有Kotlin类型属于包<code>kotlin.collections</code>）</p>
<table>
<thead>
<tr>
<th>Java type</th>
<th>Kotlin read-only type</th>
<th>Kotlin mutable type</th>
<th>Loaded platform type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Iterator<t></t></td>
<td>Iterator<t></t></td>
<td>MutableIterator<t></t></td>
<td>(Mutable)Iterator<t>!</t></td>
</tr>
<tr>
<td>Iterable<t></t></td>
<td>Iterable<t></t></td>
<td>MutableIterable<t></t></td>
<td>(Mutable)Iterable<t>!</t></td>
</tr>
<tr>
<td>Collection<t></t></td>
<td>Collection<t></t></td>
<td>MutableCollection<t></t></td>
<td>(Mutable)Collection<t>!</t></td>
</tr>
<tr>
<td>Set<t></t></td>
<td>Set<t></t></td>
<td>MutableSet<t></t></td>
<td>(Mutable)Set<t>!</t></td>
</tr>
<tr>
<td>List<t></t></td>
<td>List<t></t></td>
<td>MutableList<t></t></td>
<td>(Mutable)List<t>!</t></td>
</tr>
<tr>
<td>ListIterator<t></t></td>
<td>ListIterator<t></t></td>
<td>MutableListIterator<t></t></td>
<td>(Mutable)ListIterator<t>!</t></td>
</tr>
<tr>
<td>Map<k, v=""></k,></td>
<td>Map<k, v=""></k,></td>
<td>MutableMap<k, v=""></k,></td>
<td>(Mutable)Map<k, v="">!</k,></td>
</tr>
<tr>
<td>Map.Entry<k, v=""></k,></td>
<td>Map.Entry<k, v=""></k,></td>
<td>MutableMap.MutableEntry<k,v></k,v></td>
<td>(Mutable)Map.(Mutable)Entry<k, v="">!</k,></td>
</tr>
</tbody>
</table>
<p>Java数组按照下面规则映射</p>
<table>
<thead>
<tr>
<th>Java type</th>
<th>Kotlin type</th>
</tr>
</thead>
<tbody>
<tr>
<td>int[]</td>
<td>kotlin.IntArray!</td>
</tr>
<tr>
<td>String[]</td>
<td>kotlin.Array&lt;(out) String&gt;!</td>
</tr>
</tbody>
</table>
<h2 id="Kotlin中的Java泛型"><a href="#Kotlin中的Java泛型" class="headerlink" title="Kotlin中的Java泛型"></a>Kotlin中的Java泛型</h2><p>Kotlin的泛型与Java稍微不一样（参考<a href="https://kotlinlang.org/docs/reference/generics.html" target="_blank" rel="external">泛型</a>）。在Kotlin中导入Java类型时，要进行一些转换</p>
<ul>
<li>Java通配符转换成类型投影<ul>
<li><code>Foo&lt;? extends Bar&gt;</code> 变为<code>Foo&lt;out Bar!&gt;!</code></li>
<li><code>Foo&lt;? super Bar&gt;</code> 变为 <code>Foo&lt;in Bar!&gt;!</code></li>
</ul>
</li>
<li>Java 原始类型转换为星投影<ul>
<li><code>List</code>变为<code>List&lt;*&gt;!</code>或<code>List&lt;out Any?&gt;!</code></li>
</ul>
</li>
</ul>
<p>与Java一样，Kotlin运行时不保留泛型（如对象没有传入构造器的类型参数的信息），泛型擦除。<code>ArrayList&lt;Integer&gt;()</code>与<code>ArrayList&lt;Character&gt;()</code>两者无法区分。所以无法对带泛型类型执行<code>is</code>检查，只支持星投影泛型类型的<code>is</code>检查<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> List&lt;<span class="built_in">Int</span>&gt;) <span class="comment">// 错误：无法检查Int数组</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> List&lt;*&gt;)   <span class="comment">// 可以：数组内容没有保证</span></div></pre></td></tr></table></figure></p>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>Kotlin中数组都是不变的，表示无法将<code>Array&lt;String&gt;</code>赋值给<code>Array&lt;Any&gt;</code>，防止可能的运行出错。Kotlin同时禁止将子类数组作为超类数组参数传递给方法，但是Java允许（通过<code>Array&lt;(out) String&gt;!</code>的<a href="platform types">平台类型</a>形式）</p>
<p>Java使用基本类型数组避免装箱和拆箱操作消耗，而Kotlin隐藏这些实现细节，所以需要一个变通方案来与Java代码结合：为每个基本类型提供了特殊类（<code>IntArray</code>，<code>DoubleArray</code>，<code>CharArray</code>等），与<code>Array</code>没有关系，为了性能考虑最终编译为Java基本类型</p>
<p>假设有接收Int类型数组作为参数的Java方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaArrayExample</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIndices</span><span class="params">(<span class="keyword">int</span>[] indices)</span></span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Kotlin中调用：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> javaObj = JavaArrayExample()</div><div class="line"><span class="keyword">val</span> array = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">javaObj.removeIndices(array)  <span class="comment">// 传入int[]</span></div></pre></td></tr></table></figure></p>
<p>当编译为JVM字节码时，编译器将进行优化<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">array[x] = array[x] * <span class="number">2</span>  <span class="comment">//  </span></div><div class="line"></div><div class="line"><span class="keyword">for</span>( x <span class="keyword">in</span> array)&#123;   <span class="comment">// 不会创建迭代器</span></div><div class="line">    print(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，<code>in</code>检查也不会有额外开销<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(i <span class="keyword">in</span> array.indices)&#123;  <span class="comment">// 与(i &gt;= 0 &amp;&amp; i &lt; array.size)相同</span></div><div class="line">    print(array[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Java可变参数"><a href="#Java可变参数" class="headerlink" title="Java可变参数"></a>Java可变参数</h2><p>Java有时使用可变参数声明方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaArrayExample</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> void removeIndices(int... indices)&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Kotlin中使用<code>*</code>扩展操作符传入<code>IntArray</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> javaObj = JavaArrayExample()</div><div class="line"><span class="keyword">val</span> array = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">javaObj.removeIndicesVarArg(*array)</div></pre></td></tr></table></figure></p>
<p>目前不支持传入<code>null</code>值给参数为可变参数的方法</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>因为Java没有使用操作符语法标记方法的方式，Kotlin允许使用正确的名称和签名的方法作为操作符重载和转换（如<code>invoke()</code>等），不允许使用中缀调用语法调用Java方法。</p>
<h2 id="检查型异常"><a href="#检查型异常" class="headerlink" title="检查型异常"></a>检查型异常</h2><p>Kotlin不支持检查型异常，意味着编译器不会强制捕获检查型异常。所以当调用声明为检查型异常的方法时，Kotlin不会强制做任何检查：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">render</span><span class="params">(list: <span class="type">List</span>&lt;*&gt; , to: <span class="type">Appendable</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(item <span class="keyword">in</span> list)&#123;</div><div class="line">        to.append(item.toString())   <span class="comment">// 在Java中需要捕获 IOException 异常</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><p>Kotlin导入Java类型时，所有<code>java.lang.Object</code>类型转为<code>Any</code>。因为<code>Any</code>非平台特定，只声明了<code>toString()</code>，<code>hashCode()</code>，<code>equals()</code>成员函数，所有创建其他<code>java.lang.Object</code>对应成员函数，Kotlin使用<a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">扩展函数</a>方式来实现</p>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait()/notify()"></a>wait()/notify()</h3><p>Effective Java<a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" target="_blank" rel="external">第69条</a>建议并发工具优先于<code>wait()</code>和<code>notify()</code>，所以<code>Any</code>类型没有这些方法。如果需要使用，则可以将对象强转为<code>java.lang.Object</code>类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line">(foo <span class="keyword">as</span> java.lang.Object).wait()</div></pre></td></tr></table></figure>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>检索对象的Java类型，使用<a href="https://kotlinlang.org/docs/reference/reflection.html#class-references" target="_blank" rel="external">类引用</a>的<code>java</code>扩展属性<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> fooClass = foo::<span class="class"><span class="keyword">class</span>.<span class="title">java</span></span></div></pre></td></tr></table></figure></p>
<p>上面代码使用Kotlin 1.1 引入的<a href="https://kotlinlang.org/docs/reference/reflection.html#bound-class-references-since-11" target="_blank" rel="external">约束类引用</a>。也可以使用<code>javaClass</code>扩展属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> fooClass = foo.javaClass</div></pre></td></tr></table></figure>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>继承<code>kotlin.Cloneable</code>复写<code>clone()</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> : <span class="type">Cloneable &#123;</span></span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clone</span><span class="params">()</span></span>: Any &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>谨记<a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" target="_blank" rel="external">Effective Java第11条</a>：慎重复写<code>clone</code></p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>以声明<code>finalize</code>方式复写<code>finalize()</code>，不使用<code>override</code>关键字<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">finalize</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// finalization logic</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据Java规则，<code>finalize()</code>不能为<code>private</code></p>
<h2 id="继承Java类"><a href="#继承Java类" class="headerlink" title="继承Java类"></a>继承Java类</h2><p>Kotlin中类最多只能继承一个Java父类，但可实现多个接口</p>
<h2 id="静态成员访问"><a href="#静态成员访问" class="headerlink" title="静态成员访问"></a>静态成员访问</h2><p>Java类静态成员为<code>伴生对象</code>，不能把<code>伴生对象</code>作为值传入，但可以直接显式访问这个成员<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (Character.isLetter(a)) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>Java反射同样对Kotlin类有效，反之亦然。上面提到过可以使用<code>instance::class.java</code>、<code>ClassName::class.java</code>、<code>instance.javaClass</code>获取<code>java.lang.Class</code>进行反射</p>
<p>包括获取java的<code>setter</code>/<code>getter</code>方法、kotlin属性的<code>backing</code>字段。<code>KProperty</code>表示Java字段，<code>KFunction</code>表示Java方法或构造器。</p>
<h2 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h2><p>与Java8一样，Kotlin支持SAM（Single Abstract Method）转换，也就是说Kotlin函数字面量可以自动转换为只有单独一个方法的Java接口的实现，只要接口方法参数类型符合Kotlin函数的参数类型</p>
<p>可以用来创建SAM接口实例<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> runnable = Runnable &#123; println(<span class="string">"This runs in a runnable"</span>) &#125;</div></pre></td></tr></table></figure></p>
<p>调用<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> executor = ThreadPoolExecutor()</div><div class="line"><span class="comment">// Java签名：void execute(Runnable command)</span></div><div class="line">executor.execute &#123; println(<span class="string">"This runs in a thread pool"</span>) &#125;</div></pre></td></tr></table></figure></p>
<p>如果Java类中多个获取函数接口的方法， 可以选择其中一个调用的方法，通过一个适配器函数将Lambda转换为指定的SAM类型。编译器也会生成所需的适配器函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line">executor.execute(Runnable &#123; println(<span class="string">"This runs in a thread pool"</span>) &#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>SAM转换只适应于接口，不能用于抽象类。</p>
<p>只对与Java交互有效；因为Kotlin本身有函数类型，Kotlin接口的实现的自动转换没有必要，所以不支持。</p>
</blockquote>
<h2 id="在Kotlin中使用JNI"><a href="#在Kotlin中使用JNI" class="headerlink" title="在Kotlin中使用JNI"></a>在Kotlin中使用JNI</h2><p>Kotlin使用<code>external</code>表示函数是native(C/C++)代码实现。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line">external <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span></div></pre></td></tr></table></figure></p>
<h1 id="Java调用Kotlin"><a href="#Java调用Kotlin" class="headerlink" title="Java调用Kotlin"></a>Java调用Kotlin</h1><p>Java也可以轻松调用Kotlin代码</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>kotlin属性编译成Java</p>
<ul>
<li>Getter方法，<code>get</code>开头的方法</li>
<li>Setter方法，<code>set</code>开头的方法（只有<code>var</code>属性有）</li>
<li>private 字段，字段名与属性名相同（有backing字段的属性）</li>
</ul>
<p>如<code>var firstName: String</code>会被编译为<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> String firstName;</div><div class="line"></div><div class="line"><span class="keyword">public</span> String getFirstName()&#123;</div><div class="line">    <span class="keyword">return</span> firstName;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> void setFirstName(String firstName) &#123;</div><div class="line">    <span class="keyword">this</span>.firstName = firstName;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果属性名以<code>is</code>开头，则使用不同映射规则：</p>
<ul>
<li>Getter方法，名称与属性名一致</li>
<li>Setter方法，<code>is</code>替换为<code>set</code></li>
</ul>
<p>比如<code>var isOpen: Boolean</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> boolean isOpen</div><div class="line"></div><div class="line"><span class="keyword">public</span> boolean isOpen()&#123;</div><div class="line">    <span class="keyword">return</span> isOpen;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> void setOpen(boolean isOpen)&#123;</div><div class="line">    <span class="keyword">this</span>.isOpen = isOpen;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个规则适应于任意属性，不仅仅是Boolean</p>
<h2 id="包级函数"><a href="#包级函数" class="headerlink" title="包级函数"></a>包级函数</h2><p>包<code>org.foo.bar</code>中文件<code>example.kt</code>声明的所有函数和属性（包括扩展函数）编译成名为<code>org.foo.bar.ExampleKt</code>的Java类的静态方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// example.kt</span></div><div class="line"><span class="keyword">package</span> demo</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line">new demo.Foo();</div><div class="line">demo.ExampleKt.bar();</div></pre></td></tr></table></figure>
<p>使用<code>@JvmName</code>注解指定生成类的名称<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="meta">@file:JvmName</span>(<span class="string">"DemoUtils"</span>)</div><div class="line"></div><div class="line"><span class="keyword">package</span> demo</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"><span class="keyword">new</span> demo.Foo();</div><div class="line">demo.DemoUtils.bar();</div></pre></td></tr></table></figure>
<p>不允许有多个相同（包相同且类名相同或<code>@JvmName</code>注解名相同）Java类名文件，所以编译器只生成单个指定名称的Java外观类，这个类包含所有同名文件中的声明。Kotlin使用<code>@JvmMultifileClass</code>注解来生成这个类文件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// oldutils.kt</span></div><div class="line"><span class="meta">@file:JvmName</span>(<span class="string">"Utils"</span>)</div><div class="line"><span class="meta">@file:JvmMultifileClass</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> demo</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// newutils.kt</span></div><div class="line"><span class="meta">@file:JvmName</span>(<span class="string">"Utils"</span>)</div><div class="line"><span class="meta">@file:JvmMultifileClass</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> demo</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java调用<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line">demo.Utils.foo();</div><div class="line">demo.Utils.bar();</div></pre></td></tr></table></figure></p>
<h2 id="实例字段"><a href="#实例字段" class="headerlink" title="实例字段"></a>实例字段</h2><p>使用<code>@JvmField</code>注解，将Kotlin属性作为字段暴露给Java。字段具有与基本属性相同的可见性。</p>
<p>如果属性有<code>backing</code>字段、非private、没有<code>open</code>、<code>override</code>或<code>const</code>修饰符、并且不是委托属性，那么也可使用<code>@JvmField</code>注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Kotlin</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>(id: String)&#123;</div><div class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> ID = id</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java调用<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getID</span><span class="params">(C c)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> c.ID;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties" target="_blank" rel="external">懒初始化</a>属性也可以暴露给字段，字段的可见性与<code>lateinit</code>属性setter方法相同。</p>
<h2 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h2><p>声明在具名对象或伴生对象中的属性，则具名对象或包含伴生对象的类中有静态<code>backing</code>字段。</p>
<p>这些字段通常为<code>private</code>，但也可以通过以下其中一个方式暴露给Java</p>
<ul>
<li><code>@JvmField</code>注解</li>
<li><code>lateinit</code>修饰符</li>
<li><code>const</code>修饰符</li>
</ul>
<p>使用<code>@JvmField</code>生成一个相同可见性的静态字段<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="meta">@JvmField</span></div><div class="line">        <span class="keyword">val</span> COMPARATOR: Comparator&lt;Key&gt; = compareBy&lt;Key&gt; &#123; it.value &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line">Key.COMPARATOR.compare(key1, key2);</div><div class="line"><span class="comment">// public static final 字段</span></div></pre></td></tr></table></figure>
<p>对象或伴生对象中的<a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties" target="_blank" rel="external">懒初始化</a>对象有与setter方法相同可见性的静态<code>backing</code>字段</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">object</span> Singleton&#123;</div><div class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> provider: Provider</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line">Singleton.provider = <span class="keyword">new</span> Provider();</div><div class="line"><span class="comment">// public static 非final字段</span></div></pre></td></tr></table></figure>
<p><code>const</code>注释的属性（类中或顶层）在Java变为静态字段：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// file example.kt</span></div><div class="line"><span class="keyword">object</span> obj&#123;</div><div class="line">    const <span class="keyword">val</span> CONST = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        const <span class="keyword">val</span> VERSION = <span class="number">9</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const <span class="keyword">val</span> MAX = <span class="number">239</span></div></pre></td></tr></table></figure></p>
<p>在Java中<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> c = obj.CONST</div><div class="line"><span class="keyword">int</span> d = ExampleKt.MAX</div><div class="line"><span class="keyword">int</span> v = C.VERSION</div></pre></td></tr></table></figure></p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>Kotlin将包级函数作为静态方法处理。使用<code>@JvmStatic</code>注解定义在具名对象或伴生对象中的函数，Kotlin编译器则会在对象对应的闭合类中和对象内部生成一个静态方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Java中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">C.foo();  <span class="comment">// OK</span></div><div class="line">C.bar();  <span class="comment">// 错误：非静态方法</span></div><div class="line">C.Companion.foo() <span class="comment">// 实例方法</span></div><div class="line">C.Companion.bar(); <span class="comment">// 使用bar的唯一方式</span></div></pre></td></tr></table></figure>
<p>对具名对象同样有效<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">object</span> Obj&#123;</div><div class="line">    <span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Obj.foo(); <span class="comment">// 有效</span></div><div class="line">Obj.bar(); <span class="comment">// 无效</span></div><div class="line">Obj.INSTANCE.bar(); <span class="comment">// 有效，通过单例调用</span></div><div class="line">Obj.INSTANCE.foo(); <span class="comment">// 同样有效</span></div></pre></td></tr></table></figure>
<p><code>@JvmStatic</code>注解也可以用在对象或伴生对象的属性上，这个属相需要让它的<code>setter</code>和<code>getter</code>方法成为对象或包含伴生对象的类的静态成员。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>Kotlin可见性映射为Java规则</p>
<ul>
<li><code>private</code>成员编译为<code>private</code>成员</li>
<li><code>private</code>顶层声明编译为包本地声明</li>
<li><code>protected</code>仍然是<code>protected</code>（Java允许相同包的类访问protected成员，Kotlin则不能，Java扩大了代码的可见性）</li>
<li><code>internal</code>编译为<code>public</code>。依据Kotlin规则：<code>internal</code>类成员经过名称重编，防止Java意外调用；允许<br>重载相同签名的成员但互不可见。</li>
</ul>
<h2 id="KClass"><a href="#KClass" class="headerlink" title="KClass"></a>KClass</h2><p>有时需要调用参数类型为<code>KClass</code>的Kotlin方法，<code>Class</code>不会自动转为<code>KClass</code>类型，需要手动调用等价的<code>Class&lt;T&gt;.kotlin</code>类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line">kotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.<span class="keyword">class</span>)</div></pre></td></tr></table></figure>
<h2 id="JvmName处理签名冲突"><a href="#JvmName处理签名冲突" class="headerlink" title="@JvmName处理签名冲突"></a>@JvmName处理签名冲突</h2><p>Kotlin中具名函数需要在JVM字节码中具有不同名称。常见<em>泛型擦除</em>引起的函数签名冲突问题<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;String&gt;</span>.<span class="title">filterValid</span><span class="params">()</span></span>: List&lt;String&gt;</div><div class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Int&gt;</span>.<span class="title">filterValid</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt;</div></pre></td></tr></table></figure></p>
<p>无法同时定义上面两个函数，因为JVM签名相同：<code>filterValid(Ljava/util/List;)Ljava/util/List;</code>。使用<code>@JvmName</code>注解指定不同函数名<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;String&gt;</span>.<span class="title">filterValid</span><span class="params">()</span></span>: List&lt;String&gt;</div><div class="line"></div><div class="line"><span class="meta">@JvmName(<span class="meta-string">"filterValidInt"</span>)</span></div><div class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Int&gt;</span>.<span class="title">filterValid</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt;</div></pre></td></tr></table></figure></p>
<p>Kotlin使用相同函数名<code>filterValid</code>调用函数，Java则是<code>filterValid</code>和<code>filterValidInt</code></p>
<p>还可以用于属性名为<code>x</code>且有对应函数<code>getX()</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="keyword">val</span> x: <span class="built_in">Int</span></div><div class="line">    <span class="meta">@JvmName(<span class="meta-string">"getX_prop"</span>)</span></div><div class="line">    <span class="keyword">get</span>() = <span class="number">15</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getX</span><span class="params">()</span></span> = <span class="number">10</span></div></pre></td></tr></table></figure></p>
<h2 id="生成重载"><a href="#生成重载" class="headerlink" title="生成重载"></a>生成重载</h2><p>如果在kotlin声明带有默认值参数的函数，对于Java只能看到带有所有参数的完整签名。使用<code>@JvmOverloads</code>注解可以暴露给Java多个重载调用<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="meta">@JvmOverloads</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">Int</span> = <span class="number">0</span>, c: <span class="type">String</span> = <span class="string">"abc"</span>)</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每多有一个具有默认值的参数，就会额外生成一个重载方法。生成的重载方法移除指定参数右侧所有参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(String a, <span class="keyword">int</span> b, String c)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(String a)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>注解同样适用于构造器、静态方法等。不能用于抽象方法（包括接口中声明的方法）</p>
<blockquote>
<p>如<a href="https://kotlinlang.org/docs/reference/classes.html#secondary-constructors" target="_blank" rel="external">次要构造器</a>描述，如果所有构造器参数都具有默认参数，即使没有指定<code>@JvmOverloads</code>注解，也会生成一个无参构造器。</p>
</blockquote>
<h2 id="检查型异常-1"><a href="#检查型异常-1" class="headerlink" title="检查型异常"></a>检查型异常</h2><p>Kotlin没有检查型异常，正常情况下Kotlin函数的Java签名没有异常抛出的声明。所以如果Kotlin有以下函数<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// example.kt</span></div><div class="line"><span class="keyword">package</span> demo</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">throw</span> IOException()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java调用时，捕获异常<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  demo.Example.foo();</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// 错误: foo() 没有声明抛出IOException异常</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java编译出错，因为<code>foo()</code>没有声明抛出IOException。使用<code>@Throws</code>注解解决这个问题：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Throws(IOException::class)</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">throw</span> IOException()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h2><p>在Java调用Kotlin函数时，无法防止将<code>null</code>作为非空参数传递给函数。所以Kotlin为所有期望非空参数的public函数生成运行时检查。这样会在Java代码中立即出现<code>NullPointerException</code>异常。</p>
<h2 id="可变泛型"><a href="#可变泛型" class="headerlink" title="可变泛型"></a>可变泛型</h2><p>当Kotlin使用<a href="https://kotlinlang.org/docs/reference/generics.html#declaration-site-variance" target="_blank" rel="external">声明处变量</a>时，则在Java中有两种可选的使用方式。假设在Koltin的类声明了下面两个函数：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> value: T)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>: <span class="type">Base</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">boxDerived</span><span class="params">(value: <span class="type">Derived</span>)</span></span>: Box&lt;Derived&gt; = Box(value)</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unboxBase</span><span class="params">(box: <span class="type">Box</span>&lt;<span class="type">Base</span>&gt;)</span></span>: Base = box.value</div></pre></td></tr></table></figure></p>
<p>想当然地转为Java代码<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line">Box&lt;Derived&gt; boxDerived(Derived value) &#123; ... &#125;</div><div class="line">Base unboxBase(Box&lt;Base&gt; box) &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>Kotlin中可以这样使用<code>unboxBase(boxDerived(&quot;s&quot;))</code>，而Java不可能：因为Java中Box的参数<code>T</code>为不可变的，<code>Box&lt;Derived&gt;</code>不是<code>Box&lt;Base&gt;</code>的子类，Java需要这样定义<code>unboxBase</code>函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">Base <span class="title">unboxBase</span><span class="params">(Box&lt;? extends Base&gt; box)</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>利用Java的通配符类型（? extends Base）和<code>使用处变量</code>来模拟声明处变量。</p>
<p>为了让Kotlin API能够在Java中使用：生成<code>Box&lt;Super&gt;</code>作为<code>Box&lt;? extends Super&gt;</code>的协变量，定义<code>Box</code>（或<code>Foo&lt;? super Bar&gt;</code>作为<code>Foo</code>的逆变量）作为参数。当为返回值时，不生成通配符，否则Java需要处理这些通配符（违反Java通用编码方式），因此例子中的函数实际上转换为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回类型 -- 无通配符</span></div><div class="line">Box&lt;Derived&gt; boxDerived(Derived value) &#123; ... &#125;</div><div class="line"><span class="comment">// 参数 -- 通配符</span></div><div class="line">Base unboxBase(Box&lt;? extends Base&gt; box) &#123; ... &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>当参数类型为final（不可被继承）时，生成通配符也就毫无意义，所以无论使用什么姿势，<code>Box&lt;String&gt;</code>也就一直是<code>Box&lt;String&gt;</code>类型。</p>
</blockquote>
<p>如果默认无法生成通配符，在需要通配符时，可以使用<code>@JvmWildcard</code>注解<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">boxDerived</span><span class="params">(value: <span class="type">Derived</span>)</span></span>: Box&lt;<span class="meta">@JvmWildcard</span> Derived&gt; = Box(value)</div><div class="line"></div><div class="line"><span class="comment">// 转换为</span></div><div class="line"><span class="comment">// Base unboxBase(Box&lt;Base&gt; box) &#123; ... &#125;</span></div></pre></td></tr></table></figure></p>
<p>如果不需要生成处的通配符时，使用<code>@JvmSuppressWildcards</code>注解<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unboxBase</span><span class="params">(box: <span class="type">Box</span>&lt;@<span class="type">JvmSuppressWildcards</span> <span class="type">Base</span>&gt;)</span></span>: Base = box.value</div><div class="line"><span class="comment">// 转换为</span></div><div class="line"><span class="comment">// Base unboxBase(Box&lt;Base&gt; box) &#123; ... &#125;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>@JvmSuppressWildcards</code>不仅能用在单个类型参数处，也可以用于整体声明，如：函数、类，用作整体声明时，则忽略内部所有通配符</p>
</blockquote>
<h3 id="Nothing类型转换"><a href="#Nothing类型转换" class="headerlink" title="Nothing类型转换"></a>Nothing类型转换</h3><p><a href="https://kotlinlang.org/docs/reference/exceptions.html#the-nothing-type" target="_blank" rel="external">Nothing</a>是Kotlin的特殊类型，因为Java与之对应的类型。事实上每个Java引用类型（包括<code>java.lang.Void</code>）接受<code>null</code>作为值，Nothing甚至不接受<code>null</code>值，所以Java无法精确表示<code>Nothing</code>类型，Kotlin使用<code>Nothing</code>类型参数时会生成原始类型。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">emptyList</span><span class="params">()</span></span>: List&lt;<span class="built_in">Nothing</span>&gt; = listOf()</div><div class="line"><span class="comment">// 转换为</span></div><div class="line"><span class="comment">// List emptyList() &#123; ... &#125;</span></div></pre></td></tr></table></figure>

                <hr>

                

                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2017/07/17/Kotlin进阶之类型安全建造器、类型别名/" data-toggle="tooltip" data-placement="top" title="Kotlin进阶之类型安全建造器、类型别名">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#kotlin" title="kotlin">kotlin</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "alexwan02";
    var disqus_identifier = "http://blog.alexwan.cn/2017/07/18/Kotlin进阶之与Java交互/";
    var disqus_url = "http://blog.alexwan.cn/2017/07/18/Kotlin进阶之与Java交互/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/alexwan02">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/alexwan02">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Alex Studio 2017 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://blog.alexwan.cn/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="http://blog.alexwan.cn/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
